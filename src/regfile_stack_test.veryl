// src/regfile_stack_test.veryl

#[test(regfile_stack)]
embed (inline) sv{{{
    import veryl_stacked_regfile_RegFilePkg::*;
    module test;
        logic i_clk;
        logic i_reset;

        Command i_command;
        logic [4:0] i_a_addr;
        logic [4:0] i_b_addr;
        logic i_w_ena;
        logic [4:0] i_w_addr;
        logic [31:0] i_w_data;
        logic [31:0] o_a_data;
        logic [31:0] o_b_data;
        
        veryl_stacked_regfile_RegFileStack regfile(
            .i_clk,
            .i_reset(!i_reset), 
            .i_command,
            .i_a_addr,
            .i_b_addr,
            .i_w_ena,
            .i_w_addr,
            .i_w_data,
            .o_a_data,
            .o_b_data
        );

        initial begin
            i_clk = 0; 
            i_reset = 1; 
            i_a_addr = 0; 
            i_b_addr = 0; 
            i_w_ena = 0; 
            i_w_addr = 0; 
            i_w_data = 0; 
            i_command = Command_none;

            // hold reset
            #10; i_clk=1; #10; i_clk=0;
            assert (o_a_data == 0) else $error("0");
            assert (o_b_data == 0) else $error("0");

            // release reset
            i_reset = 0;
            #10; i_clk=1; #10; i_clk=0;
            
            // write to reg 0
            i_w_ena = 1;
            i_w_addr = 0; 
            i_w_data = 'h10;
            i_a_addr = 0;
            i_b_addr = 0;
            #10; i_clk=1; #10; i_clk=0;

            // read reg 0
            i_w_ena = 0;
            i_w_addr = 0; 
            i_w_data = 'h10;
            i_a_addr = 0;
            i_b_addr = 0;
            assert (o_a_data == 0) else $error("write to reg 0 stuck");
            assert (o_b_data == 0) else $error("write to reg 0 stuck");
            #10; i_clk=1; #10; i_clk=0;
              
            // write to reg 1
            i_w_ena = 1;
            i_w_addr = 1;
            i_w_data = 'h100;
            i_a_addr = 1;
            #10; i_clk=1; #10; i_clk=0;          

            // write to reg 2
            i_w_addr = 2;
            i_w_data = 'h1000;
            i_b_addr = 2;
            #10; i_clk=1; #10; i_clk=0;         

            // write to reg 2, with iw_ena false
            i_w_ena = 0;
            i_a_addr = 1;
            i_b_addr = 2;
            i_w_data = 'h2000;
            assert(o_a_data == 'h100) else $error("write to reg 1 failed");
            assert(o_b_data == 'h1000) else $error("write to reg 2 failed");
            #10; i_clk=1; #10; i_clk=0;     
            assert(o_b_data == 'h1000) else $error("reg 2 written with i_w_ena false");
            #10; i_clk=1; #10; i_clk=0;    

            // reset 
            i_reset = 1;
            #10; i_clk=1; #10; i_clk=0;
            assert (o_a_data == 0) else $error("0");
            assert (o_b_data == 0) else $error("0");
        
            i_reset = 0;
            #10; i_clk=1; #10; i_clk=0;

            // test stacking
            // reg[1] <- 'h1000_0000;
            i_a_addr = 1; 
            i_b_addr = 31; 
            i_w_ena = 1; 
            i_w_addr = 1; 
            i_w_data = 'h1000_0000; 

            #10; i_clk=1; #10; i_clk=0;
            assert (o_a_data == 'h1000_0000) else $error("reg 1 write failed");
            i_w_addr = 31;
            i_w_data = 'h2000_0000;
            i_a_addr = 31;
            // reg[31] <- 'h2000_0000;
            // rejected through mask 
            
            #10; i_clk=1; #10; i_clk=0;
            assert(o_a_data == 'h0000_0000) else $error("mask not masking");
            i_w_addr = 6;
            i_w_data = 'h9000_0000;
            i_b_addr = 6;
            // reg[6] <- 'h9000_0000
            #10; i_clk=1; #10; i_clk=0;
            assert(o_b_data == 'h9000_0000);
            // push
            // this is a write on interrupt dispatch == high,
            // the instruction will be retired, so write should be to "original depth"
            // we may also (externally) delay the push by a cycle but i feel thats cheating.
            i_command = Command_push;
            i_w_ena = 1;
            i_w_addr = 1; 
            i_w_data = 'h1000_1000; 
            i_a_addr = 1;
            // reg[1] <- 'h1000_1000;

            #10; i_clk=1; #10; i_clk=0;
            // this is at depth == 1
            assert (o_a_data == 'h1000_1000) else $error("write to new context");
            assert (o_b_data == 'h9000_0000) else $error("old context read");

            // nop
            i_command = Command_none; 
            i_w_addr = 6; 
            i_w_data = 'hFFFF_FFFF; 
            // reg[31] <- 'h2000_2000;
            #10; i_clk=1; #10; i_clk=0;
            assert (o_a_data == 'h1000_1000) else $error("new context, value stored");
            assert (o_b_data == 'hFFFF_FFFF) else $error("write to new context");

            // pop
            // there will NEVER be a register write on return
            // because it's done by an instruction (with no regfile write),
            // there is really no point in handling
            // this edge case
            i_command = Command_pop; 
            i_w_ena = 1;
            i_w_addr = 10;
            i_w_data = 'h1010_1010; 
            // reg[10] <- 'h1010_1010;
            #10; i_clk=1; #10; i_clk=0;
            assert (o_a_data == 'h1000_1000) else $error("old context, value 1 not restored");
            assert (o_b_data == 'h9000_0000) else $error("old context, value 2 restored (shouldnt according to stack mask)");

            // nop
            i_command = Command_none;
            i_w_ena = 0;
            i_a_addr = 10;
            #10; i_clk=1; #10; i_clk=0;
            assert (o_a_data == 'h0000_0000) else $error("old context, new value not ignored on pop");

            $finish;
         end
   endmodule
}}}
